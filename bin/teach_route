#!/usr/bin/env python

# Copyright (C) 2025 Helio Perroni Filho (xperroni@gmail.com)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#         http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

r'''Record route waypoints for later replay.

    Author: Helio Perroni Filho
'''


import rclpy
from rclpy.qos import DurabilityPolicy, HistoryPolicy, QoSProfile

from geometry_msgs import msg as geometry_msg
from nav_msgs import msg as nav_msg
from std_srvs import srv as std_srv

from tf2_ros import TransformException
from tf2_ros.buffer import Buffer
from tf2_ros.transform_listener import TransformListener

from roselito_agent import (
    get_current_pose,
    ParameterNode,
)

from roselito_interfaces.srv import SaveRouteInterface

class TeachRoute(ParameterNode):
    r'''Functions to record a route file.
    '''
    def __init__(self):
        r'''Create a new route recorder node.
        '''
        super().__init__('teach_route')

        self.declare_parameter('auto_save', False)
        self.declare_parameter('auto_save_frequency', 1.0)
        self.__auto_save = self.get_parameter("auto_save").value
        self.__auto_save_frequency = self.get_parameter('auto_save_frequency').value

        self.__buffer = Buffer()
        self.__listener = TransformListener(self.__buffer, self)

        self.__pub_route = self.create_publisher(
            nav_msg.Path, '~/route',
            QoSProfile(
                depth=1,
                durability=DurabilityPolicy.TRANSIENT_LOCAL,
                history=HistoryPolicy.KEEP_LAST
            )
        )

        self.__route = nav_msg.Path()
        self.__route.header.frame_id = self._global_frame

        self.__push = self.create_service(std_srv.Trigger, '~/push', self.__callback_push)
        self.__pop = self.create_service(std_srv.Trigger, '~/pop', self.__callback_pop)
        self.__save = self.create_service(SaveRouteInterface, '~/save', self.__callback_save)

        if self.__auto_save:
            period = 1.0 / self.__auto_save_frequency
            self.__auto_save_timer = self.create_timer(period, self.__callback_auto_save)
            self.__auto_push_timer = self.create_timer(period, self.__callback_auto_push)
            self.get_logger().info(f"Auto Saving Route Enabled.")
            self.get_logger().info(f"Setted Auto Saving Frequency : {self.__auto_save_frequency}Hz.")

    def __callback_push(self, request, response):
        r'''Handle a waypoint recording service request.
        '''
        try:
            transform = self.__buffer.lookup_transform(
                self._global_frame,
                self._robot_frame,
                rclpy.time.Time()
            )
        except TransformException as e:
            response.success = False
            response.message = f'Error computing transform from robot to global frame: "{e}"'
            return response
        
        self.__push_waypoint(transform)

        response.success = True
        return response

    def __callback_pop(self, request, response):
        r'''Handle a waypoint removal service request.
        '''
        if self.__route.poses:
            self.__route.poses.pop()
            self.__route.header.stamp = self.get_clock().now().to_msg()
            self.__pub_route.publish(self.__route)

        response.success = True
        return response

    def __callback_save(self, request, response):
        r'''Handle the route file saving service request.
        '''
        path = request.path
        if not path:
            path = self._save_path
        with open(path, 'w') as out:
            out.write(f'{repr(self.__route)}\n')

        response.success = True
        return response
    
    def __callback_auto_push(self):
        r'''Handle automatic waypoint recording.
        '''
        try:
            transform = self.__buffer.lookup_transform(
                self._global_frame,
                self._robot_frame,
                rclpy.time.Time()
            )
            self.__push_waypoint(transform)
        except TransformException as e:
            self.get_logger().info(f'Error computing transform from robot to global frame: "{e}"')
    
    def __callback_auto_save(self):
        r'''Handle the auto saving poses file.
        '''
        try:
            with open(self._save_path, 'w') as out:
                out.write(f'{repr(self.__route)}\n')
        except Exception as e:
            self.get_logger().info(f"Error while opening writing file to path '{self._save_path}' : Error {type(e).__name__}.")
    
    def __push_waypoint(self,transform) -> None:
        r'''Handle waypoint recording.
        '''
        now = self.get_clock().now().to_msg()
        self.__route.poses.append(get_current_pose(now,transform,self._global_frame))
        self.__route.header.stamp = now
        self.__pub_route.publish(self.__route)


def main():
    r'''Start the node.
    '''
    rclpy.init()

    node = TeachRoute()
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass


if __name__ == '__main__':
    main()
